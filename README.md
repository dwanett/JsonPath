Базовые возможности
-------------------

Объекты и массивы
-----------------

Объекты или массивы в jsonPath пишутся через точку.

Для сложносимвольных имен можно указать кавычки.

Таб. 1. Пример 1.

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "library": {
        "departments": [
            {
                "name": "Отдел художественной литературы"
            },
            {
                "name": "Отдел научной литературы"
            }
        ]
    }
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>library."departments".name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Отдел художественной литературы</p>
            </td>
        </tr>
    </tbody>
</table>

В случае если нет возможности указать в jsonPath имя аттрибута, можно воспользоваться символом `*`.
JsonPath будет искать наилучший короткий путь для результата. Именно поэтому в примере (2), он берет первый элемент массива. И всегда будет брать первый объект если на конце jsonPath будет стоять символ `*`

Таб. 2. Пример 2.

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "library": {
        "departments": [
            {
                "name": "Отдел художественной литературы"
            },
            {
                "name": "Отдел научной литературы"
            }
        ]
    }
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>*.*.name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Отдел художественной литературы</p>
            </td>
        </tr>
    </tbody>
</table>

В случае если объект является массивом, то можно указать индекс элемента этого массива.

Таб. 3. пример 3

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "library": {
        "departments": [
            {
                "name": "Отдел художественной литературы"
            },
            {
                "name": "Отдел научной литературы"
            }
        ]
    }
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>library.departments[1].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Отдел научной литературы</p>
            </td>
        </tr>
    </tbody>
</table>

Если индекс не был указан, то берется первый элемент (в массивах первый элемент лежит под индексом 0). То есть `library.departments.name` равносильно `library.departments[0].name`.

JsonPath может возвращать не только конкретное значение, но и массивы или объекты.

Таб. 4. пример 4

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": {
        "name": "Война и мир",
        "author": "Лев Толстой",
        "year": 1869,
        "publishingHouse": [
            "Известия",
            "Равновесие"
        ]
    }
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books.publishingHouse</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>["Известия","Равновесие"]</p>
            </td>
        </tr>
    </tbody>
</table>

Также на конце можно указать индекс `books.publishingHouse[1]`.

В jsonPath есть возможность получить массив, сформированный из конкретного поля массива объектов json.

Таб. 5. пример 5

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "library": {
        "departments": [
            {
                "name": "Отдел художественной литературы"
            },
            {
                "name": "Отдел научной литературы"
            }
        ]
    }
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>library.departments[~].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>["Отдел художественной литературы"," Отдел научной литературы "]</p>
            </td>
        </tr>
    </tbody>
</table>

Для взятия объекта у каждого элемента массива json, на место индекса необходимо вставить символ `~` .

Функции
-------

В На конце каждого jsonPath можно указать функцию. Сейчас их 4.

*   `size()` - функция получит размер массива (если это массив). 
    Если это объект, то мы получи 1 в результате выполнения функции. Если такого объекта или массива нет, то мы получим 0.
*   `sort()` - функция для сортировки массивов.  
    В случае если результатом jsonPath является массив, то отсортирует его, иначе ничего не произойдет. Функция постарается отсортировать в алфавитном порядке
*   `distinct()` - функция для удаления дубликатов в массиве.  
    Если результатом jsonPath является массив, то функция удалит дубликаты. В иных случаях ничего не произойдет.
*   `name()` - функция для получения имен аттрибутов объекта или массива.  
    Для массивов с примитивами или для примитивов не работает.


Таб. 6. пример 6

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "library": {
        "departments": [
            {
                "name": "Отдел художественной литературы"
            },
            {
                "name": "Отдел научной литературы"
            }
        ]
    }
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>library.departments[~].size()</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>2</p>
            </td>
        </tr>
    </tbody>
</table>

Таб. 7. пример 7

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "library": {
        "departments": [
            {
                "name": "Отдел художественной литературы"
            },
            {
                "name": "Отдел научной литературы"
            }
        ]
    }
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>library.departments[~].name.sort()</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>["Отдел художественной литературы"," Отдел научной литературы "]</p>
            </td>
        </tr>
    </tbody>
</table>

Фильтрация массива
------------------

Базовые операции фильтрации
---------------------------

### Наличие элемента

Для фильтрации массива необходимо использовать определенный синтаксис (`library.departments[(***)].name`). Все условия для конкретного массива необходимо записывать в круглых скобках. На месте звездочке указываются условия фильтрации

Таб. 8. пример 8

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "library": {
        "departments": [
            {
                "name": "Отдел художественной литературы",
                "floor": 4
            },
            {
                "name": "Отдел научной литературы"
            }
        ]
    }
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>library.departments[(floor)].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Отдел художественной литературы</p>
            </td>
        </tr>
    </tbody>
</table>

В примере 7, будет выполнен поиск `departments` имеющих переменную `floor`. Так же можно указать символ НЕ '!' (`library.departments[(!floor)].name`), тогда будет обратный результат. `departments`, которые не содержат `floor`

### Операции сравнения

Таб. 9. пример 9

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[(name == "Война и мир")].year</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>1869</p>
            </td>
        </tr>
    </tbody>
</table>

В примере 8. Производится поиск по всем элементам массива. Далее в результате выполнения части операции, а конкретно `books[(name == 'Война и мир')]`, будут известны элементы удовлетворяющие условию в круглых скобках. Далее year будет искать переменную в первом, соответствующем условию, элементе массива.

Операции сравнения: `==, !=, <, >, <=, >=`

**Важно! Операции сравнения `<, >, <=, >=` подходят только для числовых значений!**

### **Индекс массива**

Имеется возможность выбора элемента по индексу для получения `year`.

Таб. 10. пример 10

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "price": 100,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[(price == 100)][1].author</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Федор Достоевский</p>
            </td>
        </tr>
    </tbody>
</table>

В случае если элемента, среди удовлетворяющих условию, нет, то будет выброшено соответствующее исключение.

Таб. 11. пример 11

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "price": 100,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[(price == 100)][200].author</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>null</p>
            </td>
        </tr>
    </tbody>
</table>

Логические операции с фильтрами
-------------------------------

### Виды логических операций

В случае если есть необходимость отфильтровать по нескольким параметрам, то можно и использовать логические операции.

`&&` - логическое И

`||` - логическое ИЛИ

Таб. 12. пример 12

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "price": 100,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[(price == 100 &amp;&amp; author == "Федор Достоевский")].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Преступление и наказание</p>
            </td>
        </tr>
    </tbody>
</table>

В примере 12, по условию `price == 100` найдется 2 объекта, а условие `author == "Федор Достоевский"` внесет уточнение. В результате останется тот объект, который имеет `price == 100` и `author == "Федор Достоевский"`.

Таб. 13. пример 13

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "price": 100,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[(price == 100 || author == "Федор Достоевский")].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Лев Толстой</p>
            </td>
        </tr>
    </tbody>
</table>

В примере 13 используется логическое ИЛИ. Отличие от примера 12 в том, что в примере 13 найдено 2 элемента `books`.

### Приоритет логических операций

Существует приоритетность логических операций. Так логическое И (`&&`) выполняется раньше чем логическое ИЛИ (`||`).

Таб. 14. пример 14

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "price": 100,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        },
        {
            "name": "Структура и интерпретация компьютерных программ",
            "author": "Харольд Абельсон",
            "year": 1984,
            "price": 120,
            "publishingHouse": [
                "Союз писателей",
                "Речь"
            ]
        },
        {
            "name": "Математическая статистика с приложениями",
            "author": "Денис Смирнов",
            "year": 2018,
            "price": 120,
            "publishingHouse": [
                "Айрис пресс",
                "Равновесие"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[(price == 100 &amp;&amp; author == "Федор Достоевский" || price == 120 &amp;&amp; author
                    == "Денис Смирнов")][1].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Математическая статистика с приложениями</p>
            </td>
        </tr>
    </tbody>
</table>

Таб. 15. Приоритет операций в примере 14.

<table><colgroup><col> <col></colgroup><tbody><tr><td><p>Приоритет</p></td><td><p>Операция</p></td></tr><tr><td><p>1</p></td><td><p>price == 100 &amp;&amp; author == "Федор Достоевский"</p></td></tr><tr><td><p>2</p></td><td><p>price == 120 &amp;&amp; author == "Денис Смирнов"</p></td></tr><tr><td><p>3</p></td><td><p>(1) || (2)</p></td></tr></tbody></table>

- где (1) – результат операции с приоритетом 1, (2) результат операции с приоритетом 2.

### Приоритезация логических операций

Есть возможность самому указать приоритет операций. Операцию/и необходимо взять в фигурные скобки.

Таб. 16. пример 15

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "price": 100,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        },
        {
            "name": "Структура и интерпретация компьютерных программ",
            "author": "Харольд Абельсон",
            "year": 1984,
            "price": 120,
            "publishingHouse": [
                "Союз писателей",
                "Речь"
            ]
        },
        {
            "name": "Математическая статистика с приложениями",
            "author": "Денис Смирнов",
            "year": 2018,
            "price": 100,
            "publishingHouse": [
                "Айрис пресс",
                "Равновесие"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[({author == "Денис Смирнов" || author == "Лев Толстой"} &amp;&amp; price == 120)].name
                </p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Математическая статистика с приложениями</p>
            </td>
        </tr>
    </tbody>
</table>

Таблица 17. Приоритет операций в примере 15.

<table><colgroup><col> <col></colgroup><tbody><tr><td><p>Приоритет</p></td><td><p>Операция</p></td></tr><tr><td><p>1</p></td><td><p>author == "Денис Смирнов" || author == "Лев Толстой"</p></td></tr><tr><td><p>2</p></td><td><p>price == 120</p></td></tr><tr><td><p>3</p></td><td><p>(1) &amp;&amp; (2)</p></td></tr></tbody></table>

- где (1) – результат операции с приоритетом 1, (2) результат операции с приоритетом 2.

Фигурные скобки (приоритизация) поддерживают множественную вложенность и на одном уровне вложенности их может быть неограниченное количество.

Другие операции
---------------

`allMatch` – все объекты удовлетворяют условию

`nonMatch` – ни один объект не удовлетворяет условию

Таблица 18. Пример конвертации результата с операциями `allMatch` и `nonMatch`.

<table><colgroup><col> <col> <col></colgroup><tbody><tr><td><p>allMatch(true, true, true)</p></td><td><p>&gt;&gt;</p></td><td><p>(true, true, true)</p></td></tr><tr><td><p>allMatch(true, false, true)</p></td><td><p>&gt;&gt;</p></td><td><p>(false, false, false)</p></td></tr><tr><td><p>nonMatch(false, false, false)</p></td><td><p>&gt;&gt;</p></td><td><p>(true, true, true)</p></td></tr><tr><td><p>nonMatch(false, true, false)</p></td><td><p>&gt;&gt;</p></td><td><p>(false, false, false)</p></td></tr></tbody></table>

Таб. 19. пример 16

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "price": 100,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        },
        {
            "name": "Структура и интерпретация компьютерных программ",
            "author": "Харольд Абельсон",
            "year": 1984,
            "price": 120,
            "publishingHouse": [
                "Союз писателей",
                "Речь"
            ]
        },
        {
            "name": "Математическая статистика с приложениями",
            "author": "Денис Смирнов",
            "year": 2018,
            "price": 100,
            "publishingHouse": [
                "Айрис пресс",
                "Равновесие"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[allMatch(price == 120 || price == 100)].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Война и мир</p>
            </td>
        </tr>
    </tbody>
</table>

Также условие может содержать не только переменные текущего объекта, но и массивы, которые могут содержать все выше перечисленное.

Таб. 20. пример 17

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "library": {
        "departments": [
            {
                "name": "Отдел художественной литературы",
                "books": [
                    {
                        "name": "Война и мир",
                        "author": "Лев Толстой",
                        "year": 1869,
                        "price": 100,
                        "publishingHouse": [
                            "Известия",
                            "Равновесие"
                        ]
                    },
                    {
                        "name": "Преступление и наказание",
                        "author": "Федор Достоевский",
                        "year": 1866,
                        "price": 100,
                        "publishingHouse": [
                            "Калан",
                            "Аквариум"
                        ]
                    }
                ],
                "staff": [
                    {
                        "name": "Иван Иванов",
                        "post": "Библиотекарь"
                    },
                    {
                        "name": "Анна Петрова",
                        "post": "Куратор отдела"
                    }
                ]
            },
            {
                "name": "Отдел научной литературы",
                "books": [
                    {
                        "name": "Структура и интерпретация компьютерных программ",
                        "author": "Харольд Абельсон",
                        "year": 1984,
                        "price": 120,
                        "publishingHouse": [
                            "Союз писателей",
                            "Речь"
                        ]
                    },
                    {
                        "name": "Математическая статистика с приложениями",
                        "author": "Денис Смирнов",
                        "year": 2018,
                        "price": 120,
                        "publishingHouse": [
                            "Айрис пресс",
                            "Равновесие"
                        ]
                    }
                ],
                "staff": [
                    {
                        "name": "Павел Сидоров",
                        "post": "Библиотекарь"
                    },
                    {
                        "name": "Мария Иванова",
                        "post": "Куратор отдела"
                    },
                    {
                        "name": "Иван Петров",
                        "post": "Уборщик"
                    }
                ]
            }
        ]
    }
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>library.departments[(staff[(post == "Библиотекарь")] &amp;&amp; books[(price == 100 &amp;&amp; year
                    == 1866)])].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Отдел художественной литературы</p>
            </td>
        </tr>
    </tbody>
</table>

Дополнительные возможности проверки значений
--------------------------------------------

### **Регулярные выражения**

Можно указать регулярное выражение. Шаблон будет выглядеть следующим образом: `reg("*")`. Тут вместо звездочки необходимо подставить регулярное выражение.

Таб. 21. пример 18

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "price": 100,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[(price == 100 &amp;&amp; author == reg("[а-яА-Я]*"))].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Война и мир</p>
            </td>
        </tr>
    </tbody>
</table>

### **Поиск по вхождению подстроки**

Также есть функция `contains("*")`. Тут вместо звездочки необходимо подставить подстроку, которую должна содержать строка для удовлетворения условия.

Таб. 22. пример 19

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "price": 100,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[(author == contains("Федор"))].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Преступление и наказание</p>
            </td>
        </tr>
    </tbody>
</table>

### **Проверка на null**

Проверка на значение null

Таб. 23. пример 20

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": null,
            "year": 1869,
            "price": 100,
            "publishingHouse": [
                "Известия",
                "Равновесие"
            ]
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[(author == null)].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Война и мир</p>
            </td>
        </tr>
    </tbody>
</table>

### **Проверка на empty**

Проверка на пустой объект или массив

Таб. 24. пример 21

<table>
    <colgroup>
        <col>
        <col>
    </colgroup>
    <tbody>
        <tr>
            <td>
                <p>JSON</p>
            </td>
            <td>
<pre>
{
    "books": [
        {
            "name": "Война и мир",
            "author": "Лев Толстой",
            "year": 1869,
            "price": 100,
            "publishingHouse": []
        },
        {
            "name": "Преступление и наказание",
            "author": "Федор Достоевский",
            "year": 1866,
            "price": 100,
            "publishingHouse": [
                "Калан",
                "Аквариум"
            ]
        }
    ]
}
</pre>
            </td>
        </tr>
        <tr>
            <td>
                <p>jsonPath</p>
            </td>
            <td>
                <p>books[(publishingHouse == empty)].name</p>
            </td>
        </tr>
        <tr>
            <td>
                <p>Результат</p>
            </td>
            <td>
                <p>Война и мир</p>
            </td>
        </tr>
    </tbody>
</table>